"""
Receptionist Bot:
1. Chatterbot - is used to display ATM card data and answer project specific questions.
2. ChatGPT - is used to answer general questions.
3. sqlLite3 - is used to create Database.
4. gTTS (google Text to Speech) - is used to read out the bot responses.
5. pySide2 - is used to create the GUI.
"""

# Import modules from pySide2 library for GUI:
from PySide2.QtWidgets import QLabel, QPushButton, QLineEdit, QWidget, QApplication
from PySide2.QtCore import Qt

# Import Libraries:

# used for chatterbot:
from chatterbot import ChatBot
from chatterbot.trainers import ListTrainer

# used to create database:
import sqlite3
from tabulate import tabulate

# Necessary for text to speech conversion:
import io
from gtts import gTTS
import pygame

# Necessary for chatgpt:
import openai
openai.api_key = '' # your openAI API key

application = QApplication([]) # object to control the application's control flow
main_window = QWidget() # creates the main window
main_window.setWindowTitle("Receptionist Bot")
main_window.setGeometry(50, 50, 1200, 600) # x,y, length, and height
main_window.setStyleSheet("background-color: white;")


# Function to get response from chatgpt:
def get_chatgpt_response(input):
    response = openai.ChatCompletion.create(model="gpt-3.5-turbo", messages=[
        {"role": "user", "content": input}])
    return response.choices[0].message.content # get the first response generated by chatgpt (i.e., choice = 0)


# function to convert text to speech:
def text_to_speech(text):
    tts = gTTS(text=str(text))

    speech_stream = io.BytesIO() # An in memory stream is created to store the speech in it
    tts.write_to_fp(speech_stream) # writing the speech to the memory stream created above
    speech_stream.seek(0) # Setting the stream position to 0, to read the audio data from the beginning

# Using mixer module to play the audio:
    pygame.mixer.init()
    pygame.mixer.music.load(speech_stream)
    pygame.mixer.music.play()

# loop to check after every 10 seconds if the audio is still playing:
    while pygame.mixer.music.get_busy():
        pygame.time.Clock().tick(10)  # Check every 10 milliseconds

    pygame.mixer.music.stop()


conn = sqlite3.connect('Receptionistbot_database.db') # making a connection to our database
cursor = conn.cursor() # cursor object allows to use sqlite3 commands, and interact with the database


# Create a new ChatBot instance:
chatbot = ChatBot(
    'ReceptionistBot',
    storage_adapter='chatterbot.storage.SQLStorageAdapter', # bot's data will be stored in a SQL database
    # chatbot will reply with the "best match answer" from the existing conversation corpus
    logic_adapter='chatterbot.logic.BestMatch',
    database_uri='sqlite:///RecepBot_database.sqlite3' # URI where bot's data will be stored
)
trainer = ListTrainer(chatbot) # ListTrainer is used to train chatbot with custom conversations

# Bot training part:
# Information related to ATM Card: "First line is the input by the user and Second line is the response of the bot"
trainer.train([
    "I need help",
    "Sure, I am available!",
    "Hello, can you help me?",
    "Of course, that's what I'm meant to do, please provide me with the details",
    "I want to check my account details",
    "Understood, to proceed, please provide me with your ATM card number",
    "I want to check my account information",
    "Understood, to proceed, please provide me with your ATM card number",
    "I want to check my account balance",
    "Understood, to proceed, please provide me with your ATM card number",
    "ATM",
    "If you want to check your account details, please provide me with your ATM Card number",
    "Card",
    "If you want to check your account details, please provide me with your ATM Card number",
    "Number",
    "If you want to check your account details, please provide me with your ATM Card number"
])
# Intro of the bot:
trainer.train([
    "Tell me about yourself",
    "I am a Receptionist Bot, ready to help customers",
    "Introduce yourself please",
    "I am a Receptionist Bot, I provide assistance to customers",
    "Can you introduce yourself?",
    "Of course, I am a Receptionist Bot",
    "Give me your introduction?",
    "I am a Receptionist Bot :)",
    "who are you?",
    "I am a Receptionist Bot",
    "Are you really a bot?",
    "Yes, 100%",
    "Are you a receptionist bot?",
    "Yes, 100%"
])


# Database part:
# Function to read all card numbers from the dataset file:
def read_card_number_from_file():
    cursor.execute('SELECT card_number FROM Card_data') # execute the query
    reader = cursor.fetchall() # contains a list of tuples. Each tuple contains the card number

    # for loop to iterate through each tuple in the list and row[0] to extract the first and only element of the tuple
    return [row[0] for row in reader] # A list containing all the card numbers.


# creating a list of the card numbers:
all_card_numbers_list = read_card_number_from_file()


# Function to check if the input contains a valid card number:
def contains_number(input_text, card_numbers):
    for number in card_numbers:
        if number in input_text:
            return True, number
    return False, input_text


# Function to get data from the dataset file:
def get_data_from_file(number):
    cursor.execute('SELECT * FROM Card_data')
    reader = cursor.fetchall()
    headers = ["Total Balance", "Transactions", "Card Holder Name", "Last Activity Date", "Last Transaction"]
    for row in reader:
        if row[0] == number: # check if first row is matching with the user input, if matching extract all the data
            return dict(zip(headers[0:], row[1:]))
    return "I'm sorry, I don't have details for that card."

# this function will be called when user submits his name:
def update_label3():
    label4.setText(f"{entry.text()}: ") # displaying the username on label4
    label1.clear()
    label3.setText(f"ReceptionistBot: Hello {entry.text()}! I'm a ReceptionistBot. How can I help you today?")
    text_to_speech(f"Hello! I'm a ReceptionistBot. How can I help you today?")
    label3.setStyleSheet('color: black; font-weight: bold; font-size: 11px;')
    entry.clear()

# Creating some Labels:
label0 = QLabel("Receptionist Bot GUI", main_window)
label0.setStyleSheet('color: Black; font-weight: bold; font-size: 18px; background-color: #4CAF50; color: white; border-radius: 1px;')
label0.setGeometry(512.5, 5, 188, 50)

label1 = QLabel("Please enter your name below to proceed !!", main_window)
label1.setStyleSheet('color: black; font-weight: bold; font-size: 11px;')
label1.setGeometry(20, 30, 300, 30)

label2 = QLabel("Name:", main_window)
label2.setStyleSheet('color: black; font-weight: bold; font-size: 11px;')
label2.setGeometry(20, 70, 75, 30)

# create an entry to get username:
entry = QLineEdit(main_window)
entry.setGeometry(190, 70, 200, 30)
query = entry.text() # save the username in a variable

# create a button to save the username:
button = QPushButton('Submit', main_window)
button.setStyleSheet('background-color: #4CAF50; color: white; border-radius: 2px;') # changing the background of the button
button.setGeometry(250, 105, 80, 30)

# if button is clicked call and execute the function "update_label3"
button.clicked.connect(update_label3)

# create some more labels
label3 = QLabel("", main_window)
label3.setGeometry(20, 150, 550, 30)

label4 = QLabel("", main_window)
label4.setStyleSheet('color: black; font-weight: bold; font-size: 11px;')
label4.setGeometry(20, 207.5, 100, 15)

# create entry to get user input, user can input anything in this entry:
user_input = QLineEdit(main_window)
user_input.setGeometry(150, 200, 300, 30)

# user will press this button to submit his input in the system:
button1 = QPushButton('Enter', main_window)
button1.setStyleSheet('background-color: #4CAF50; color: white; border-radius: 2px;')
button1.setGeometry(250, 235, 80, 30)

# create some more labels:
label5 = QLabel("ChatBot Response: ", main_window)
label5.setStyleSheet('color: black; font-weight: bold; font-size: 11px;')
label5.setGeometry(600, 60, 150, 30)

# label to display chatbot response:
label6 = QLabel("", main_window)
label6.setStyleSheet('color: black; font-size: 14px; border: 2px solid black; padding: 5px;')
label6.setGeometry(600, 100, 550, 450)
label6.setAlignment(Qt.AlignTop | Qt.AlignLeft) # aligning the text to top left of the label
label6.setWordWrap(True) # wrapping the text to start the next line when the first line is ended

# program will stop when user input any of these words:
exit_conditions = ("bye", "okay bye", "okay goodbye","take care, bye", "ok take care", "ok bye",
                   "goodbye", "exit", "takecare", "Ali")


# this function will be called when user inputs any question/query in the user_input entry:
def save_user_input():
    query = user_input.text() # saving the user input in a variable named "query"
    print(f"User: {query}")
    user_input.clear()
    label6.clear()
    if query.lower() in exit_conditions: # if user inputs any word from the exit_conditions, then quit the application
        label6.setText("Goodbye!")
        text_to_speech("Take-care, Goodbye")
        application.quit()

    # a list of words, which when entered then the chatterbot receptionist Bot will response, otherwise chatgpt will reply
    key_words = ["help", "information", "ATM", "card", "number", "need", "details", "balance",
                 "introduce", "receptionist", "introduction"]
    # this variable will be true, if user input matches with any of the words present in the key_words list
    matched_word = any(word in query.lower() for word in key_words)

    # call the function to see if the user_input is matching with any card number from our database
    has_number, ATM_CardNumber= contains_number(query, all_card_numbers_list)
    if has_number: # if number matched then get the data for that card from database
        data_row = get_data_from_file(ATM_CardNumber)
        # empty lists to contain the data if the card number entered by user matches with our database:
        headers = []
        account_info = []
        if data_row:
            for header, value in data_row.items(): # iterating through the key:value pair in the dictionary
                headers.append(header) # append the headers to a new list
                account_info.append(value) # append the account information to a new list
            print(tabulate([account_info], headers=headers)) # print in tabular form

            formatted_info = "\n".join([f"{header}: {value}" for header, value in data_row.items()])
            label6.setText(f"Sure sir, Here's the data for {ATM_CardNumber}:\n\n{formatted_info}")

            print(f"ReceptionistBot: Sure sir, Here's the data for {ATM_CardNumber}:")
            text_to_speech("Sure sir, I've displayed the data for the card on the screen")
    # if number entered by user didn't match with our database record:
    else:
        # check if the first 4 digits of the user input are digits:
        if query[0:3].isdigit():
            label6.setText(f"Sorry, I couldn't find data for {ATM_CardNumber}, please try again!")

            print(f"ReceptionistBot: Sorry, I couldn't find data for {ATM_CardNumber}, please try again!")
            text_to_speech("Sorry, I couldn't find data for this card, please try again!")

        # check if user input contains any word from the key_words list, chatterbot will reply in this case from trained data
        elif matched_word:
            response = chatbot.get_response(query)
            label6.setAlignment(Qt.AlignTop | Qt.AlignLeft)
            label6.setWordWrap(True)
            label6.setText(str(response))

            print(f"ReceptionistBot: {response}")
            text_to_speech(response)
        # otherwise, chatgpt will reply to the user input:
        else:
            response = get_chatgpt_response(query)
            label6.setText(response)

            print(f"ChatGPT - ReceptionistBot: {response}")
            text_to_speech(response)


# the above function will be called when user presses button 1 on the GUI (after entering his question/query)
button1.clicked.connect(save_user_input)

main_window.show() # display the main GUI window
application.exec_() # initiating the event loop, allowing the GUI to respond to the user inputs as per code's logic
